---
layout: post
title: C语言实现itoa和atoi
category: 算法
tags: 算法 Algorithm itoa  atoi
---

前几天面试被问到一个问题，用c实现atoi函数，也就是将字符串转为int型整数。  
这个算法其实很容易想到，尤其是咱们中国人。因为我们计数都是权值形式的，  
比如：122，就是一百二十二，1个100，2个20，1个2  
对于我们来说是很明显的事情。因为中文将这个表述的很清楚，英语的话就差一些了。  

显而易见的算法，就是读取各个数字乘上它相应的权值，最后加起来就可以了。  
但是权值得获取是一个问题。  
例如：122，首先读取的数字是1，怎么判断它是十位百位还是个位呢？  
显然可以反过来干，先读取个位的数。这样的话就需要遍历两遍，或者需要传入  
字符串的长度。这个就比较麻烦。  

如果想要一次遍历就结束，而且不需要知道字符串长度的话，该怎么做呢？  
首先，看一下遍历的过程：  
对于122这个数字来说，我们会先读取1，然后是2，最后是最后一个2.  
跟我们书写的顺序是一样的，先写1，再写2，最后还是2.  
然后写在纸上的话就是：开始是1，然后变成12，最后变成122  
可以发现他们变化的过程就是：0 &#8727; 10+1，1 &#8727; 10+2，12 &#8727; 10+2  
这个过程就是我们的算法了。一次性遍历就可以解决问题了。而且不需要知道字符串的长度。  

以上的东西，其实只是核心算法，因为输入是字符串，所以我们还需要处理不合理输入的问题。  
空格啊，字母啊，特殊字符等等。  
这些字符共同的特征就是不属于阿拉伯数字的字符。也就是不再0-9内。  
所以当遇到这些字符就可以返回了。至于是返回错误还是返回什么就可以自己定义了。  

我这里为了简化实现，在遇到不合理字符时，就返回已有的结果。以下就是我的实现：
  
	int A2i(const char  &#8727;  a)
	{
		int isMinus=a[0]=='-';
		char  &#8727; c=isMinus||a[0]=='+'?a+1:a;	//跳过正负号 
		int res=0;
		while( &#8727; c!='\0')
		{
			if( &#8727; c>=0|| &#8727; c<=9)
			{
				res=(res<<1)+(res<<3)+ &#8727; c-'0';//根据权值构造数字,这里用移位实现了res &#8727; 10的操作
			}
			else
			{
				break;
			} 
			c++;
		}
		return isMinus?-res:res;
	}

以上就是i2a的实现了，当然我在面试的时候写的代码，犯了一些错误，都是语法错误。c语言确实忘了好多。  
而且我用的是黑名单，不是白名单。  

然后回家后，我又想了itoa的实现。感觉不像上面那样简单。要稍微复杂一点。  
因为itoa，需要将10进制转换为不同进制下的字符串表示。而且我找不到能够一遍做完的算法。查了下现有的实现，  
一般都需要两遍，第一次根据相应权值得出的字符串还需要再逆序转为正确的结果。  
我直接附上一份网上找到的实现吧： 
 
	char &#8727; I2a(int num,char  &#8727; str,int radix)
	{
	　　// 索引表 
	　　char index[]="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	　　unsigned unum; // 中间变量 
	　　int i=0,j,k;
	　　// 确定unum的值 
	　　if(radix==10&&num<0) // 十进制负数 
	　　{
	　　	unum=(unsigned)-num;
	　　	str[i++]='-';
	　　}
	　　else unum=(unsigned)num; // 其他情况 
	　　// 逆序 
	　　do
	　　{
	　　	str[i++]=index[unum%(unsigned)radix];
	　　	unum/=radix;
	　　}while(unum);
	　　str='\0';
	　　// 转换 
	　　if(str[0]=='-') k=1; // 十进制负数 
	　　else k=0;
	　　// 将原来的“/2”改为“/2.0”，保证当num在16~255之间，radix等于16时，也能得到正确结果 
	　　for(j=k;j<(i-1)/2.0+k;j++) 
	　　{
		　　num=str[j];
	　　	str[j]=str[i-j-1+k];
		　　str[i-j-1+k]=num;
	　　}
	　　return str;
	}


